// Copyright 2015 Ian Dawes. All rights reserved.
// Use of this source code is governed by a MIT
// license that can be found in the LICENSE file.

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"path/filepath"
)

type writer struct {
	pkg      string
	typename string
	buf      bytes.Buffer
}

func newWriter(pkg string, typename string) *writer {
	w := writer{pkg: pkg, typename: typename}
	w.printf(`
//
// AUTO-GENERATED by metago. DO NOT EDIT!
//

`)
	w.printf("package %s\n\n", filepath.Base(pkg))
	return &w
}

func (w *writer) printf(format string, args ...interface{}) {
	fmt.Fprintf(&w.buf, format, args...)
}

func (w *writer) close() error {
	buf, err := format.Source(w.buf.Bytes())
	if err != nil {
		// generate a view of the output with line numbers to allow for easier location of the error.
		b := &bytes.Buffer{}
		r := bufio.NewReader(&w.buf)
		for i := 1; ; i++ {
			l, err := r.ReadString('\n')
			if err != nil {
				break
			}
			fmt.Fprintf(b, "%d %s", i, l)
		}
		return fmt.Errorf("\n%s\n  Couldn't format generated src: %s\n", string(b.Bytes()), err)
	}
	fn := filepath.Join(w.pkg, fmt.Sprintf("%s.go", w.typename))
	fmt.Printf("Checking file: %s\n", fn)
	if !isChanged(buf, fn) {
		return nil
	}
	fmt.Printf("     %s ---------------Changed\n", w.typename)
	return ioutil.WriteFile(fn, buf, 0755)
}

func isChanged(newData []byte, fn string) bool {
	oldData, err := ioutil.ReadFile(fn)
	if err != nil {
		return true
	}
	return !bytes.Equal(oldData, newData)
}
