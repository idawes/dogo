//
// AUTO-GENERATED by metago. DO NOT EDIT!
//

package test

import (
	"github.com/davecgh/go-spew/spew"
	"github.com/idawes/metago"
	"time"
)

type SliceTestObject struct {
	ByteSlice     []byte
	U8Slice       []uint8
	U16Slice      []uint16
	U32Slice      []uint32
	U64Slice      []uint64
	S8Slice       []int8
	S16Slice      []int16
	S32Slice      []int32
	S64Slice      []int64
	StringSlice   []string
	TimeSlice     []time.Time
	String2dSlice [][]string
}

func (this *SliceTestObject) Dump() string {
	return spew.Sdump(*this)
}

func (o1 *SliceTestObject) Equals(o2 *SliceTestObject) bool {

	{
		va, vb := o1.ByteSlice, o2.ByteSlice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.U8Slice, o2.U8Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.U16Slice, o2.U16Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.U32Slice, o2.U32Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.U64Slice, o2.U64Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.S8Slice, o2.S8Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.S16Slice, o2.S16Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.S32Slice, o2.S32Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.S64Slice, o2.S64Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.StringSlice, o2.StringSlice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.TimeSlice, o2.TimeSlice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1.Equal(vb1) {
				return false
			}
		}
	}

	{
		va, vb := o1.String2dSlice, o2.String2dSlice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if len(va1) != len(vb1) {
				return false
			}
			for idx1, va11 := range va1 {
				vb11 := vb1[idx1]
				if va11 != vb11 {
					return false
				}
			}
		}
	}
	return true
}

func (o1 *SliceTestObject) Diff(o2 *SliceTestObject) *metago.Diff {
	chgs := make([]metago.Chg, 0)

	{
		va, vb := o1.ByteSlice, o2.ByteSlice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				chgs1 := make([]metago.Chg, 0)
				if va1 != vb1 {
					chgs1 = append(chgs1, metago.NewByteChg(&SliceTestObjectByteSliceSREF, vb1, va1))
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectByteSliceSREF, idx, metago.ChangeTypeModify, chgs1))
				}
			} else {
				chgs1 := make([]metago.Chg, 0)
				chgs1 = append(chgs1, metago.NewByteChg(&SliceTestObjectByteSliceSREF, va1))
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectByteSliceSREF, idx, metago.ChangeTypeInsert, chgs1))
				}
			}
		}
		for idx, vb1 := range vb {
			chgs1 := make([]metago.Chg, 0)
			chgs1 = append(chgs1, metago.NewByteChg(&SliceTestObjectByteSliceSREF, vb1))
			if len(chgs1) != 0 {
				chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectByteSliceSREF, idx, metago.ChangeTypeDelete, chgs1))
			}
		}
	}

	{
		va, vb := o1.U8Slice, o2.U8Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				chgs1 := make([]metago.Chg, 0)
				if va1 != vb1 {
					chgs1 = append(chgs1, metago.NewUint8Chg(&SliceTestObjectU8SliceSREF, vb1, va1))
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectU8SliceSREF, idx, metago.ChangeTypeModify, chgs1))
				}
			} else {
				chgs1 := make([]metago.Chg, 0)
				chgs1 = append(chgs1, metago.NewUint8Chg(&SliceTestObjectU8SliceSREF, va1))
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectU8SliceSREF, idx, metago.ChangeTypeInsert, chgs1))
				}
			}
		}
		for idx, vb1 := range vb {
			chgs1 := make([]metago.Chg, 0)
			chgs1 = append(chgs1, metago.NewUint8Chg(&SliceTestObjectU8SliceSREF, vb1))
			if len(chgs1) != 0 {
				chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectU8SliceSREF, idx, metago.ChangeTypeDelete, chgs1))
			}
		}
	}

	{
		va, vb := o1.U16Slice, o2.U16Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				chgs1 := make([]metago.Chg, 0)
				if va1 != vb1 {
					chgs1 = append(chgs1, metago.NewUint16Chg(&SliceTestObjectU16SliceSREF, vb1, va1))
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectU16SliceSREF, idx, metago.ChangeTypeModify, chgs1))
				}
			} else {
				chgs1 := make([]metago.Chg, 0)
				chgs1 = append(chgs1, metago.NewUint16Chg(&SliceTestObjectU16SliceSREF, va1))
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectU16SliceSREF, idx, metago.ChangeTypeInsert, chgs1))
				}
			}
		}
		for idx, vb1 := range vb {
			chgs1 := make([]metago.Chg, 0)
			chgs1 = append(chgs1, metago.NewUint16Chg(&SliceTestObjectU16SliceSREF, vb1))
			if len(chgs1) != 0 {
				chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectU16SliceSREF, idx, metago.ChangeTypeDelete, chgs1))
			}
		}
	}

	{
		va, vb := o1.U32Slice, o2.U32Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				chgs1 := make([]metago.Chg, 0)
				if va1 != vb1 {
					chgs1 = append(chgs1, metago.NewUint32Chg(&SliceTestObjectU32SliceSREF, vb1, va1))
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectU32SliceSREF, idx, metago.ChangeTypeModify, chgs1))
				}
			} else {
				chgs1 := make([]metago.Chg, 0)
				chgs1 = append(chgs1, metago.NewUint32Chg(&SliceTestObjectU32SliceSREF, va1))
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectU32SliceSREF, idx, metago.ChangeTypeInsert, chgs1))
				}
			}
		}
		for idx, vb1 := range vb {
			chgs1 := make([]metago.Chg, 0)
			chgs1 = append(chgs1, metago.NewUint32Chg(&SliceTestObjectU32SliceSREF, vb1))
			if len(chgs1) != 0 {
				chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectU32SliceSREF, idx, metago.ChangeTypeDelete, chgs1))
			}
		}
	}

	{
		va, vb := o1.U64Slice, o2.U64Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				chgs1 := make([]metago.Chg, 0)
				if va1 != vb1 {
					chgs1 = append(chgs1, metago.NewUint64Chg(&SliceTestObjectU64SliceSREF, vb1, va1))
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectU64SliceSREF, idx, metago.ChangeTypeModify, chgs1))
				}
			} else {
				chgs1 := make([]metago.Chg, 0)
				chgs1 = append(chgs1, metago.NewUint64Chg(&SliceTestObjectU64SliceSREF, va1))
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectU64SliceSREF, idx, metago.ChangeTypeInsert, chgs1))
				}
			}
		}
		for idx, vb1 := range vb {
			chgs1 := make([]metago.Chg, 0)
			chgs1 = append(chgs1, metago.NewUint64Chg(&SliceTestObjectU64SliceSREF, vb1))
			if len(chgs1) != 0 {
				chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectU64SliceSREF, idx, metago.ChangeTypeDelete, chgs1))
			}
		}
	}

	{
		va, vb := o1.S8Slice, o2.S8Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				chgs1 := make([]metago.Chg, 0)
				if va1 != vb1 {
					chgs1 = append(chgs1, metago.NewInt8Chg(&SliceTestObjectS8SliceSREF, vb1, va1))
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectS8SliceSREF, idx, metago.ChangeTypeModify, chgs1))
				}
			} else {
				chgs1 := make([]metago.Chg, 0)
				chgs1 = append(chgs1, metago.NewInt8Chg(&SliceTestObjectS8SliceSREF, va1))
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectS8SliceSREF, idx, metago.ChangeTypeInsert, chgs1))
				}
			}
		}
		for idx, vb1 := range vb {
			chgs1 := make([]metago.Chg, 0)
			chgs1 = append(chgs1, metago.NewInt8Chg(&SliceTestObjectS8SliceSREF, vb1))
			if len(chgs1) != 0 {
				chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectS8SliceSREF, idx, metago.ChangeTypeDelete, chgs1))
			}
		}
	}

	{
		va, vb := o1.S16Slice, o2.S16Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				chgs1 := make([]metago.Chg, 0)
				if va1 != vb1 {
					chgs1 = append(chgs1, metago.NewInt16Chg(&SliceTestObjectS16SliceSREF, vb1, va1))
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectS16SliceSREF, idx, metago.ChangeTypeModify, chgs1))
				}
			} else {
				chgs1 := make([]metago.Chg, 0)
				chgs1 = append(chgs1, metago.NewInt16Chg(&SliceTestObjectS16SliceSREF, va1))
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectS16SliceSREF, idx, metago.ChangeTypeInsert, chgs1))
				}
			}
		}
		for idx, vb1 := range vb {
			chgs1 := make([]metago.Chg, 0)
			chgs1 = append(chgs1, metago.NewInt16Chg(&SliceTestObjectS16SliceSREF, vb1))
			if len(chgs1) != 0 {
				chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectS16SliceSREF, idx, metago.ChangeTypeDelete, chgs1))
			}
		}
	}

	{
		va, vb := o1.S32Slice, o2.S32Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				chgs1 := make([]metago.Chg, 0)
				if va1 != vb1 {
					chgs1 = append(chgs1, metago.NewInt32Chg(&SliceTestObjectS32SliceSREF, vb1, va1))
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectS32SliceSREF, idx, metago.ChangeTypeModify, chgs1))
				}
			} else {
				chgs1 := make([]metago.Chg, 0)
				chgs1 = append(chgs1, metago.NewInt32Chg(&SliceTestObjectS32SliceSREF, va1))
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectS32SliceSREF, idx, metago.ChangeTypeInsert, chgs1))
				}
			}
		}
		for idx, vb1 := range vb {
			chgs1 := make([]metago.Chg, 0)
			chgs1 = append(chgs1, metago.NewInt32Chg(&SliceTestObjectS32SliceSREF, vb1))
			if len(chgs1) != 0 {
				chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectS32SliceSREF, idx, metago.ChangeTypeDelete, chgs1))
			}
		}
	}

	{
		va, vb := o1.S64Slice, o2.S64Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				chgs1 := make([]metago.Chg, 0)
				if va1 != vb1 {
					chgs1 = append(chgs1, metago.NewInt64Chg(&SliceTestObjectS64SliceSREF, vb1, va1))
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectS64SliceSREF, idx, metago.ChangeTypeModify, chgs1))
				}
			} else {
				chgs1 := make([]metago.Chg, 0)
				chgs1 = append(chgs1, metago.NewInt64Chg(&SliceTestObjectS64SliceSREF, va1))
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectS64SliceSREF, idx, metago.ChangeTypeInsert, chgs1))
				}
			}
		}
		for idx, vb1 := range vb {
			chgs1 := make([]metago.Chg, 0)
			chgs1 = append(chgs1, metago.NewInt64Chg(&SliceTestObjectS64SliceSREF, vb1))
			if len(chgs1) != 0 {
				chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectS64SliceSREF, idx, metago.ChangeTypeDelete, chgs1))
			}
		}
	}

	{
		va, vb := o1.StringSlice, o2.StringSlice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				chgs1 := make([]metago.Chg, 0)
				if va1 != vb1 {
					chgs1 = append(chgs1, metago.NewStringChg(&SliceTestObjectStringSliceSREF, vb1, va1))
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectStringSliceSREF, idx, metago.ChangeTypeModify, chgs1))
				}
			} else {
				chgs1 := make([]metago.Chg, 0)
				chgs1 = append(chgs1, metago.NewStringChg(&SliceTestObjectStringSliceSREF, va1))
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectStringSliceSREF, idx, metago.ChangeTypeInsert, chgs1))
				}
			}
		}
		for idx, vb1 := range vb {
			chgs1 := make([]metago.Chg, 0)
			chgs1 = append(chgs1, metago.NewStringChg(&SliceTestObjectStringSliceSREF, vb1))
			if len(chgs1) != 0 {
				chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectStringSliceSREF, idx, metago.ChangeTypeDelete, chgs1))
			}
		}
	}

	{
		va, vb := o1.TimeSlice, o2.TimeSlice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				chgs1 := make([]metago.Chg, 0)
				if va1.Equal(vb1) {
					chgs1 = append(chgs1, metago.NewTimeChg(&SliceTestObjectTimeSliceSREF, vb1, va1))
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectTimeSliceSREF, idx, metago.ChangeTypeModify, chgs1))
				}
			} else {
				chgs1 := make([]metago.Chg, 0)
				chgs1 = append(chgs1, metago.NewTimeChg(&SliceTestObjectTimeSliceSREF, va1))
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectTimeSliceSREF, idx, metago.ChangeTypeInsert, chgs1))
				}
			}
		}
		for idx, vb1 := range vb {
			chgs1 := make([]metago.Chg, 0)
			chgs1 = append(chgs1, metago.NewTimeChg(&SliceTestObjectTimeSliceSREF, vb1))
			if len(chgs1) != 0 {
				chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectTimeSliceSREF, idx, metago.ChangeTypeDelete, chgs1))
			}
		}
	}

	{
		va, vb := o1.String2dSlice, o2.String2dSlice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				chgs1 := make([]metago.Chg, 0)
				for idx1, va11 := range va1 {
					if idx1 < len(vb1) {
						vb11 := vb1[idx1]
						chgs11 := make([]metago.Chg, 0)
						if va11 != vb11 {
							chgs11 = append(chgs11, metago.NewStringChg(&SliceTestObjectString2dSliceSREF, vb11, va11))
						}
						if len(chgs11) != 0 {
							chgs1 = append(chgs1, metago.NewSliceChg(&SliceTestObjectString2dSliceSREF, idx1, metago.ChangeTypeModify, chgs11))
						}
					} else {
						chgs11 := make([]metago.Chg, 0)
						chgs11 = append(chgs11, metago.NewStringChg(&SliceTestObjectString2dSliceSREF, va11))
						if len(chgs11) != 0 {
							chgs1 = append(chgs1, metago.NewSliceChg(&SliceTestObjectString2dSliceSREF, idx1, metago.ChangeTypeInsert, chgs11))
						}
					}
				}
				for idx1, vb11 := range vb1 {
					chgs11 := make([]metago.Chg, 0)
					chgs11 = append(chgs11, metago.NewStringChg(&SliceTestObjectString2dSliceSREF, vb11))
					if len(chgs11) != 0 {
						chgs1 = append(chgs1, metago.NewSliceChg(&SliceTestObjectString2dSliceSREF, idx1, metago.ChangeTypeDelete, chgs11))
					}
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectString2dSliceSREF, idx, metago.ChangeTypeModify, chgs1))
				}
			} else {
				chgs1 := make([]metago.Chg, 0)
				for idx1, va11 := range va1 {
					chgs11 := make([]metago.Chg, 0)
					chgs11 = append(chgs11, metago.NewStringChg(&SliceTestObjectString2dSliceSREF, va11))
					if len(chgs11) != 0 {
						chgs1 = append(chgs1, metago.NewSliceChg(&SliceTestObjectString2dSliceSREF, idx1, metago.ChangeTypeInsert, chgs11))
					}
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectString2dSliceSREF, idx, metago.ChangeTypeInsert, chgs1))
				}
			}
		}
		for idx, vb1 := range vb {
			chgs1 := make([]metago.Chg, 0)
			for idx1, vb11 := range vb1 {
				chgs11 := make([]metago.Chg, 0)
				chgs11 = append(chgs11, metago.NewStringChg(&SliceTestObjectString2dSliceSREF, vb11))
				if len(chgs11) != 0 {
					chgs1 = append(chgs1, metago.NewSliceChg(&SliceTestObjectString2dSliceSREF, idx1, metago.ChangeTypeDelete, chgs11))
				}
			}
			if len(chgs1) != 0 {
				chgs = append(chgs, metago.NewSliceChg(&SliceTestObjectString2dSliceSREF, idx, metago.ChangeTypeDelete, chgs1))
			}
		}
	}
	return &metago.Diff{Chgs: chgs}
}

func (o *SliceTestObject) Apply(d *metago.Diff) error {
	for _, c := range d.Chgs {
		switch c.AttributeID() {

		}
	}
	return nil
}
