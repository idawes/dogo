//
// AUTO-GENERATED by metago. DO NOT EDIT!
//

package test

import (
	"github.com/davecgh/go-spew/spew"
	"github.com/idawes/metago"
	"time"
)

type SliceTestObject struct {
	ByteSlice     []byte
	U8Slice       []uint8
	U16Slice      []uint16
	U32Slice      []uint32
	U64Slice      []uint64
	S8Slice       []int8
	S16Slice      []int16
	S32Slice      []int32
	S64Slice      []int64
	StringSlice   []string
	TimeSlice     []time.Time
	String2dSlice [][]string
}

func (this *SliceTestObject) Dump() string {
	return spew.Sdump(*this)
}

func (o1 *SliceTestObject) Equals(o2 *SliceTestObject) bool {

	{
		va, vb := o1.ByteSlice, o2.ByteSlice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.U8Slice, o2.U8Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.U16Slice, o2.U16Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.U32Slice, o2.U32Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.U64Slice, o2.U64Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.S8Slice, o2.S8Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.S16Slice, o2.S16Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.S32Slice, o2.S32Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.S64Slice, o2.S64Slice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.StringSlice, o2.StringSlice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1 != vb1 {
				return false
			}
		}
	}

	{
		va, vb := o1.TimeSlice, o2.TimeSlice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if va1.Equal(vb1) {
				return false
			}
		}
	}

	{
		va, vb := o1.String2dSlice, o2.String2dSlice
		if len(va) != len(vb) {
			return false
		}
		for idx, va1 := range va {
			vb1 := vb[idx]
			if len(va1) != len(vb1) {
				return false
			}
			for idx1, va11 := range va1 {
				vb11 := vb1[idx1]
				if va11 != vb11 {
					return false
				}
			}
		}
	}
	return true
}

func (o1 *SliceTestObject) Diff(o2 *SliceTestObject) (d *metago.Diff) {

	{
		va, vb := o1.ByteSlice, o2.ByteSlice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				d1 := metago.Diff{}
				if va1 != vb1 {
					d.Add(NewbyteChg(SliceTestObject, true, vb1, va1))
				}
				d1.Changes = append(d.Changes, metago.NewSliceChg(SliceTestObjectByteSliceAID, idx, metago.ChangeTypeModify, &d))
			}
		}
	}

	{
		va, vb := o1.U8Slice, o2.U8Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				d1 := metago.Diff{}
				if va1 != vb1 {
					d.Add(Newuint8Chg(SliceTestObject, true, vb1, va1))
				}
				d1.Changes = append(d.Changes, metago.NewSliceChg(SliceTestObjectU8SliceAID, idx, metago.ChangeTypeModify, &d))
			}
		}
	}

	{
		va, vb := o1.U16Slice, o2.U16Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				d1 := metago.Diff{}
				if va1 != vb1 {
					d.Add(Newuint16Chg(SliceTestObject, true, vb1, va1))
				}
				d1.Changes = append(d.Changes, metago.NewSliceChg(SliceTestObjectU16SliceAID, idx, metago.ChangeTypeModify, &d))
			}
		}
	}

	{
		va, vb := o1.U32Slice, o2.U32Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				d1 := metago.Diff{}
				if va1 != vb1 {
					d.Add(Newuint32Chg(SliceTestObject, true, vb1, va1))
				}
				d1.Changes = append(d.Changes, metago.NewSliceChg(SliceTestObjectU32SliceAID, idx, metago.ChangeTypeModify, &d))
			}
		}
	}

	{
		va, vb := o1.U64Slice, o2.U64Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				d1 := metago.Diff{}
				if va1 != vb1 {
					d.Add(Newuint64Chg(SliceTestObject, true, vb1, va1))
				}
				d1.Changes = append(d.Changes, metago.NewSliceChg(SliceTestObjectU64SliceAID, idx, metago.ChangeTypeModify, &d))
			}
		}
	}

	{
		va, vb := o1.S8Slice, o2.S8Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				d1 := metago.Diff{}
				if va1 != vb1 {
					d.Add(Newint8Chg(SliceTestObject, true, vb1, va1))
				}
				d1.Changes = append(d.Changes, metago.NewSliceChg(SliceTestObjectS8SliceAID, idx, metago.ChangeTypeModify, &d))
			}
		}
	}

	{
		va, vb := o1.S16Slice, o2.S16Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				d1 := metago.Diff{}
				if va1 != vb1 {
					d.Add(Newint16Chg(SliceTestObject, true, vb1, va1))
				}
				d1.Changes = append(d.Changes, metago.NewSliceChg(SliceTestObjectS16SliceAID, idx, metago.ChangeTypeModify, &d))
			}
		}
	}

	{
		va, vb := o1.S32Slice, o2.S32Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				d1 := metago.Diff{}
				if va1 != vb1 {
					d.Add(Newint32Chg(SliceTestObject, true, vb1, va1))
				}
				d1.Changes = append(d.Changes, metago.NewSliceChg(SliceTestObjectS32SliceAID, idx, metago.ChangeTypeModify, &d))
			}
		}
	}

	{
		va, vb := o1.S64Slice, o2.S64Slice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				d1 := metago.Diff{}
				if va1 != vb1 {
					d.Add(Newint64Chg(SliceTestObject, true, vb1, va1))
				}
				d1.Changes = append(d.Changes, metago.NewSliceChg(SliceTestObjectS64SliceAID, idx, metago.ChangeTypeModify, &d))
			}
		}
	}

	{
		va, vb := o1.StringSlice, o2.StringSlice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				d1 := metago.Diff{}
				if va1 != vb1 {
					d.Add(NewstringChg(SliceTestObject, true, vb1, va1))
				}
				d1.Changes = append(d.Changes, metago.NewSliceChg(SliceTestObjectStringSliceAID, idx, metago.ChangeTypeModify, &d))
			}
		}
	}

	{
		va, vb := o1.TimeSlice, o2.TimeSlice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				d1 := metago.Diff{}
				if vaSliceTestObject.Equal(vbSliceTestObject) {
					d.Add(NewTimeChg(Time.Time, true, vbSliceTestObject, vaSliceTestObject))
				}
				d1.Changes = append(d.Changes, metago.NewSliceChg(SliceTestObjectTimeSliceAID, idx, metago.ChangeTypeModify, &d))
			}
		}
	}

	{
		va, vb := o1.String2dSlice, o2.String2dSlice
		for idx, va1 := range va {
			if idx < len(vb) {
				vb1 := vb[idx]
				d1 := metago.Diff{}
				for idx1, va11 := range va1 {
					if idx1 < len(vb1) {
						vb11 := vb1[idx1]
						d11 := metago.Diff{}
						if va11 != vb11 {
							d.Add(NewstringChg(SliceTestObject, true, vb11, va11))
						}
						d11.Changes = append(d1.Changes, metago.NewSliceChg(SliceTestObjectAID, idx1, metago.ChangeTypeModify, &d1))
					}
				}
				d1.Changes = append(d.Changes, metago.NewSliceChg(SliceTestObjectString2dSliceAID, idx, metago.ChangeTypeModify, &d))
			}
		}
	}
	return true
}
