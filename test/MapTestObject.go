//
// AUTO-GENERATED by metago. DO NOT EDIT!
//

package test

import (
	"github.com/idawes/metago"
)

type MapTestObject struct {
	o1 map[byte]string
	o2 map[byte]map[byte]string
}

func (o1 *MapTestObject) Equals(o2 *MapTestObject) bool {

	{
		va, vb := o1.o1, o2.o1
		if len(va) != len(vb) {
			return false
		}
		for key, va1 := range va {
			if vb1, ok := vb[key]; ok {
				if va1 != vb1 {
					return false
				}
			} else {
				return false // didn't find key in vb
			}
		}
	}

	{
		va, vb := o1.o2, o2.o2
		if len(va) != len(vb) {
			return false
		}
		for key, va1 := range va {
			if vb1, ok := vb[key]; ok {
				if len(va1) != len(vb1) {
					return false
				}
				for key1, va11 := range va1 {
					if vb11, ok := vb1[key1]; ok {
						if va11 != vb11 {
							return false
						}
					} else {
						return false // didn't find key1 in vb1
					}
				}
			} else {
				return false // didn't find key in vb
			}
		}
	}
	return true
}

func (o1 *MapTestObject) Diff(o2 *MapTestObject) *metago.Diff {
	d := &metago.Diff{}

	{
		va, vb := o1.o1, o2.o1
		for key, va1 := range va {
			if vb1, ok := vb[key]; ok {
				d1 := &metago.Diff{}
				if va1 != vb1 {
					d1.Add(metago.NewStringChg(&MapTestObjecto1SREF, vb1, va1))
				}
				if len(d1.Chgs) != 0 {
					d.Chgs = append(d.Chgs, metago.NewByteMapChg(&MapTestObjecto1SREF, key, metago.ChangeTypeModify, d1))
				}
			} else {
				d1 := &metago.Diff{}
				d1.Add(metago.NewStringChg(&MapTestObjecto1SREF, va1))
				if len(d1.Chgs) != 0 {
					d.Chgs = append(d.Chgs, metago.NewByteMapChg(&MapTestObjecto1SREF, key, metago.ChangeTypeInsert, d1))
				}
			}
		}
		for key, vb1 := range vb {
			d1 := &metago.Diff{}
			d1.Add(metago.NewStringChg(&MapTestObjecto1SREF, vb1))
			if len(d1.Chgs) != 0 {
				d.Chgs = append(d.Chgs, metago.NewByteMapChg(&MapTestObjecto1SREF, key, metago.ChangeTypeDelete, d1))
			}
		}
	}

	{
		va, vb := o1.o2, o2.o2
		for key, va1 := range va {
			if vb1, ok := vb[key]; ok {
				d1 := &metago.Diff{}
				for key1, va11 := range va1 {
					if vb11, ok := vb1[key1]; ok {
						d11 := &metago.Diff{}
						if va11 != vb11 {
							d11.Add(metago.NewStringChg(&MapTestObjecto2SREF, vb11, va11))
						}
						if len(d11.Chgs) != 0 {
							d1.Chgs = append(d1.Chgs, metago.NewByteMapChg(&MapTestObjecto2SREF, key1, metago.ChangeTypeModify, d11))
						}
					} else {
						d11 := &metago.Diff{}
						d11.Add(metago.NewStringChg(&MapTestObjecto2SREF, va11))
						if len(d11.Chgs) != 0 {
							d1.Chgs = append(d1.Chgs, metago.NewByteMapChg(&MapTestObjecto2SREF, key1, metago.ChangeTypeInsert, d11))
						}
					}
				}
				for key1, vb11 := range vb1 {
					d11 := &metago.Diff{}
					d11.Add(metago.NewStringChg(&MapTestObjecto2SREF, vb11))
					if len(d11.Chgs) != 0 {
						d1.Chgs = append(d1.Chgs, metago.NewByteMapChg(&MapTestObjecto2SREF, key1, metago.ChangeTypeDelete, d11))
					}
				}
				if len(d1.Chgs) != 0 {
					d.Chgs = append(d.Chgs, metago.NewByteMapChg(&MapTestObjecto2SREF, key, metago.ChangeTypeModify, d1))
				}
			} else {
				d1 := &metago.Diff{}
				for key1, va11 := range va1 {
					d11 := &metago.Diff{}
					d11.Add(metago.NewStringChg(&MapTestObjecto2SREF, va11))
					if len(d11.Chgs) != 0 {
						d1.Chgs = append(d1.Chgs, metago.NewByteMapChg(&MapTestObjecto2SREF, key1, metago.ChangeTypeInsert, d11))
					}
				}
				if len(d1.Chgs) != 0 {
					d.Chgs = append(d.Chgs, metago.NewByteMapChg(&MapTestObjecto2SREF, key, metago.ChangeTypeInsert, d1))
				}
			}
		}
		for key, vb1 := range vb {
			d1 := &metago.Diff{}
			for key1, vb11 := range vb1 {
				d11 := &metago.Diff{}
				d11.Add(metago.NewStringChg(&MapTestObjecto2SREF, vb11))
				if len(d11.Chgs) != 0 {
					d1.Chgs = append(d1.Chgs, metago.NewByteMapChg(&MapTestObjecto2SREF, key1, metago.ChangeTypeDelete, d11))
				}
			}
			if len(d1.Chgs) != 0 {
				d.Chgs = append(d.Chgs, metago.NewByteMapChg(&MapTestObjecto2SREF, key, metago.ChangeTypeDelete, d1))
			}
		}
	}
	return d
}

func (o *MapTestObject) Apply(d *metago.Diff) error {
	for _, c := range d.Chgs {
		switch c.AttributeID() {

		case &MapTestObjecto1AID:
			{
				m := o.o1
				mc := c.(*metago.ByteMapChg)
				key := mc.Key
				switch mc.Typ {
				case metago.ChangeTypeModify:
					c1 := mc.Chgs.Chgs[0]
					m[key] = c1.(*metago.StringChg).NewValue
				case metago.ChangeTypeInsert:
				case metago.ChangeTypeDelete:
				}
			}

		case &MapTestObjecto2AID:
			{
				m := o.o2
				mc := c.(*metago.ByteMapChg)
				key := mc.Key
				switch mc.Typ {
				case metago.ChangeTypeModify:
					for _, c1 := range mc.Chgs.Chgs {
					}
				case metago.ChangeTypeInsert:
				case metago.ChangeTypeDelete:
				}
			}
		}
	}
	return nil
}
