//
// AUTO-GENERATED by metago. DO NOT EDIT!
//

package test

import (
	"github.com/idawes/metago"
	"time"
)

type MapTestObject struct {
	o1 map[byte]time.Time
	o2 map[byte]map[byte]string
}

func (o1 MapTestObject) Equals(o2 MapTestObject) bool {

	{
		va, vb := o1.o1, o2.o1
		if len(va) != len(vb) {
			return false
		}
		for key, va1 := range va {
			if vb1, ok := vb[key]; ok {
				if !va1.Equal(vb1) {
					return false
				}
			} else {
				return false // didn't find key in vb
			}
		}
	}

	{
		va, vb := o1.o2, o2.o2
		if len(va) != len(vb) {
			return false
		}
		for key, va1 := range va {
			if vb1, ok := vb[key]; ok {
				if len(va1) != len(vb1) {
					return false
				}
				for key1, va11 := range va1 {
					if vb11, ok := vb1[key1]; ok {
						if va11 != vb11 {
							return false
						}
					} else {
						return false // didn't find key1 in vb1
					}
				}
			} else {
				return false // didn't find key in vb
			}
		}
	}
	return true
}

// Diff returns a record of the differences between o1 and o2 such that applying the generated record to o1 would make it equal to o2
func (o1 MapTestObject) Diff(o2 MapTestObject) metago.Diff {
	chgs := make([]metago.Chg, 0)

	{
		va, vb := o1.o1, o2.o1
		for key, va1 := range va {
			if vb1, ok := vb[key]; ok {
				// "key" exists in both "va" and "vb"
				chgs1 := make([]metago.Chg, 0)
				if !va1.Equal(vb1) {
					chgs1 = append(chgs1, metago.NewTimeChg(&MapTestObjecto1SREF, vb1, va1))
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewByteMapChg(&MapTestObjecto1SREF, key, metago.ChangeTypeModify, chgs1))
				}
			} else {
				// "key" exists in "va" but not in "vb"
				chgs1 := make([]metago.Chg, 0)
				chgs1 = append(chgs1, metago.NewTimeChg(&MapTestObjecto1SREF, va1))
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewByteMapChg(&MapTestObjecto1SREF, key, metago.ChangeTypeDelete, chgs1))
				}
			}
		}
		for key, vb1 := range vb {
			if _, ok := va[key]; ok {
				continue
			}
			// "key" exists in vb but not int va"
			chgs1 := make([]metago.Chg, 0)
			chgs1 = append(chgs1, metago.NewTimeChg(&MapTestObjecto1SREF, vb1))
			if len(chgs1) != 0 {
				chgs = append(chgs, metago.NewByteMapChg(&MapTestObjecto1SREF, key, metago.ChangeTypeInsert, chgs1))
			}
		}
	}

	{
		va, vb := o1.o2, o2.o2
		for key, va1 := range va {
			if vb1, ok := vb[key]; ok {
				// "key" exists in both "va" and "vb"
				chgs1 := make([]metago.Chg, 0)
				for key1, va11 := range va1 {
					if vb11, ok := vb1[key1]; ok {
						// "key1" exists in both "va1" and "vb1"
						chgs11 := make([]metago.Chg, 0)
						if va11 != vb11 {
							chgs11 = append(chgs11, metago.NewStringChg(&MapTestObjecto2SREF, vb11, va11))
						}
						if len(chgs11) != 0 {
							chgs1 = append(chgs1, metago.NewByteMapChg(&MapTestObjecto2SREF, key1, metago.ChangeTypeModify, chgs11))
						}
					} else {
						// "key1" exists in "va1" but not in "vb1"
						chgs11 := make([]metago.Chg, 0)
						chgs11 = append(chgs11, metago.NewStringChg(&MapTestObjecto2SREF, va11))
						if len(chgs11) != 0 {
							chgs1 = append(chgs1, metago.NewByteMapChg(&MapTestObjecto2SREF, key1, metago.ChangeTypeDelete, chgs11))
						}
					}
				}
				for key1, vb11 := range vb1 {
					if _, ok := va1[key1]; ok {
						continue
					}
					// "key1" exists in vb1 but not int va1"
					chgs11 := make([]metago.Chg, 0)
					chgs11 = append(chgs11, metago.NewStringChg(&MapTestObjecto2SREF, vb11))
					if len(chgs11) != 0 {
						chgs1 = append(chgs1, metago.NewByteMapChg(&MapTestObjecto2SREF, key1, metago.ChangeTypeInsert, chgs11))
					}
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewByteMapChg(&MapTestObjecto2SREF, key, metago.ChangeTypeModify, chgs1))
				}
			} else {
				// "key" exists in "va" but not in "vb"
				chgs1 := make([]metago.Chg, 0)
				for key1, va11 := range va1 {
					chgs11 := make([]metago.Chg, 0)
					chgs11 = append(chgs11, metago.NewStringChg(&MapTestObjecto2SREF, va11))
					if len(chgs11) != 0 {
						chgs1 = append(chgs1, metago.NewByteMapChg(&MapTestObjecto2SREF, key1, metago.ChangeTypeDelete, chgs11))
					}
				}
				if len(chgs1) != 0 {
					chgs = append(chgs, metago.NewByteMapChg(&MapTestObjecto2SREF, key, metago.ChangeTypeDelete, chgs1))
				}
			}
		}
		for key, vb1 := range vb {
			if _, ok := va[key]; ok {
				continue
			}
			// "key" exists in vb but not int va"
			chgs1 := make([]metago.Chg, 0)
			for key1, vb11 := range vb1 {
				// "key1" exists in "va1" but not in "vb1"
				chgs11 := make([]metago.Chg, 0)
				chgs11 = append(chgs11, metago.NewStringChg(&MapTestObjecto2SREF, vb11))
				if len(chgs11) != 0 {
					chgs1 = append(chgs1, metago.NewByteMapChg(&MapTestObjecto2SREF, key1, metago.ChangeTypeInsert, chgs11))
				}
			}
			if len(chgs1) != 0 {
				chgs = append(chgs, metago.NewByteMapChg(&MapTestObjecto2SREF, key, metago.ChangeTypeInsert, chgs1))
			}
		}
	}
	return metago.Diff{Chgs: chgs}
}

func (orig *MapTestObject) Apply(d metago.Diff) error {
	for _, c := range d.Chgs {
		switch c.AttributeID() {

		case &MapTestObjecto1AID:
			{
				m := orig.o1
				mc := c.(*metago.ByteMapChg)
				key := mc.Key
				switch mc.Typ {
				case metago.ChangeTypeModify:
					m[key] = mc.Chgs[0].(*metago.TimeChg).NewValue
				case metago.ChangeTypeInsert:
					m[key] = mc.Chgs[0].(*metago.TimeChg).NewValue
				case metago.ChangeTypeDelete:
					delete(m, key)
				}
			}

		case &MapTestObjecto2AID:
			{
				m := orig.o2
				mc := c.(*metago.ByteMapChg)
				key := mc.Key
				switch mc.Typ {
				case metago.ChangeTypeModify:
					for _, c1 := range mc.Chgs {
						m1 := m[key]
						mc1 := c1.(*metago.ByteMapChg)
						key1 := mc1.Key
						switch mc1.Typ {
						case metago.ChangeTypeModify:
							m1[key1] = mc1.Chgs[0].(*metago.StringChg).NewValue
						case metago.ChangeTypeInsert:
							m1[key1] = mc1.Chgs[0].(*metago.StringChg).NewValue
						case metago.ChangeTypeDelete:
							delete(m1, key1)
						}
					}
				case metago.ChangeTypeInsert:
					for _, c1 := range mc.Chgs {
						m1 := m[key]
						mc1 := c1.(*metago.ByteMapChg)
						key1 := mc1.Key
						switch mc1.Typ {
						case metago.ChangeTypeModify:
							m1[key1] = mc1.Chgs[0].(*metago.StringChg).NewValue
						case metago.ChangeTypeInsert:
							m1[key1] = mc1.Chgs[0].(*metago.StringChg).NewValue
						case metago.ChangeTypeDelete:
							delete(m1, key1)
						}
					}
				case metago.ChangeTypeDelete:
					delete(m, key)
				}
			}
		}
	}
	return nil
}
